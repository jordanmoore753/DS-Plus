<div id="holder-links">
  <p>Sometimes, the built-in data structures in <em>JavaScript</em> simply aren't adequate for the application being developed.</p>
  <p>Fear not. <em>Plus</em> gives developers fast and reliable data structures.</p>
  <p>All objects in the <em>Plus</em> class are initialized with the <code class="code">new</code> keyword and a constructor function.</p>
  <p>Click on any of the following links to view the documentation for a given <code class="code">class</code>.</p>
  <ul id="links-classes">
    <li class="link-class-item">
      <a href="#queue" data-id='queue'>Queue</a>
    </li>
    <li class="link-class-item">
      <a data-id='stack' href="#stack">Stack</a>
    </li>
    <li class="link-class-item">
      <a data-id='linkedlist' href="#linkedlist">Linked List</a>
    </li>
    <li class="link-class-item">
      <a data-id='bt' href="#bt">Binary Tree</a>
    </li>
    <li class="link-class-item">
      <a data-id='bst' href="#bst">Binary Search Tree</a>
    </li>
  </ul>
  <hr>
</div>

<section id="queue" class="doc-section">
  <h1 class="ds-heading">Queue</h1>
  <p>Queues are very easy to implement with <em>Plus</em>. There are two initialization options for the data storage in the queue: an array, or a linked list.</p>
  <h2 class="method-heading">Methods</h2>
  <code class="code">constructor(data = null)</code>
  <p class="method-p">Initialize a new <code class="parameter">Queue</code> object. Possible parameter(s) are: <code class="parameter">'linkedlist'</code>.</p>
{% highlight javascript %}
let Queue = new Plus.Queue();
let Queue = new Plus.Queue('linkedlist');
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">Queue</code> object has the following structure:</p>
{% highlight javascript %}
{
  data: [] || 'Linked List',
  ll: true || false
}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">enqueue(...arguments)</code>
  <p class="method-p">Appends element(s) to the end of the <code class="parameter">data</code> property. To pass several elements at once, simply separate each element by a comma.</p>
{% highlight javascript %}
Queue.enqueue(1);
Queue.enqueue(2, 3, 4);
Queue.enqueue('string', true, [1, 2, 3], { one: 'more' });
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">dequeue()</code>
  <p class="method-p">Removes and returns the first element from the <code class="parameter">data</code> property. Returns <code class="parameter">null</code> if the store is empty.</p>
{% highlight javascript %}
Queue.enqueue(1);
Queue.dequeue();  // 1
Queue.dequeue();  // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">front()</code>
  <p class="method-p">Returns the first element or node from the <code class="parameter">data</code> property. Returns <code class="parameter">undefined</code> or <code class="parameter">null</code> if there are no elements.</p>
{% highlight javascript %}
Queue.enqueue(1);
Queue.front();              // 1
LinkedListQueue.enqueue(1);
LinkedListQueue.front();    // { val: 1, next: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">rear()</code>
  <p class="method-p">Returns the last element or node from the <code class="parameter">data</code> property. Returns <code class="parameter">undefined</code> or <code class="parameter">null</code> if there are no elements.</p>
{% highlight javascript %}
Queue.enqueue(1, 2);
Queue.rear();                  // 2
LinkedListQueue.enqueue(1, 2);
LinkedListQueue.rear();        // { val: 2, next: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">search(value)</code>
  <p class="method-p">Returns the element or node from the <code class="parameter">data</code> property if it exists. Returns <code class="parameter">null</code> if there are no elements.</p>
{% highlight javascript %}
Queue.enqueue(1);
Queue.search(1);              // 1
Queue.search(3);              // null
LinkedListQueue.enqueue(1);
LinkedListQueue.search(1);    // { val: 1, next: null }
LinkedListQueue.search(3);    // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <a href="#title" class="topper">Back to Top</a>
</section>

<section id="stack" class="doc-section">
  <h1 class="ds-heading">Stack</h1>
  <p>Stacks are almost identical to the <code class="code">Queue</code> objects in <em>Plus</em>. There are also only two initialization options for the data storage in the queue: an array, or a linked list.</p>
  <h2 class="method-heading">Methods</h2>
  <code class="code">constructor(data = null)</code>
  <p class="method-p">Initialize a new <code class="parameter">Stack</code> object. Possible parameter(s) are: <code class="parameter">'linkedlist'</code>.</p>
{% highlight javascript %}
let Stack = new Plus.Stack();
let Stack = new Plus.Stack('linkedlist');
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">Stack</code> object has the following structure:</p>
{% highlight javascript %}
{
  data: [] || 'Linked List',
  ll: true || false
}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">push(...arguments)</code>
  <p class="method-p">Appends element(s) to the end of the <code class="parameter">data</code> property. To pass several elements at once, simply separate each element by a comma.</p>
{% highlight javascript %}
Stack.push(1);
Stack.push(2, 3, 4);
Stack.push('string', true, [1, 2, 3], { one: 'more' });
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">pop()</code>
  <p class="method-p">Removes and returns the last element from the <code class="parameter">data</code> property. Returns <code class="parameter">null</code> if the store is empty.</p>
{% highlight javascript %}
Stack.push(1);
Stack.pop();  // 1
Stack.pop();  // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">peek()</code>
  <p class="method-p">Returns the last element or node from the <code class="parameter">data</code> property. Returns <code class="parameter">undefined</code> or <code class="parameter">null</code> if there are no elements.</p>
{% highlight javascript %}
Stack.push(1, 2);
Stack.peek();              // 2
LinkedListStack.push(1, 2);
LinkedListStack.peek();    // { val: 2, next: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">isEmpty()</code>
  <p class="method-p">Returns <code class="parameter">true || false</code> based on whether the <code class="parameter">data</code> property has data or not.</p>
{% highlight javascript %}
Stack.push(1, 2);
Stack.isEmpty();  // false
Stack.pop();
Stack.pop();
Stack.isEmpty();  // true
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">search(value)</code>
  <p class="method-p">Returns the element or node from the <code class="parameter">data</code> property if it exists. Returns <code class="parameter">null</code> if there are no elements.</p>
{% highlight javascript %}
Stack.push(1);
Stack.search(1);              // 1
Stack.search(3);              // null
LinkedListStack.push(1);
LinkedListStack.search(1);    // { val: 1, next: null }
LinkedListStack.search(3);    // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <a href="#title" class="topper">Back to Top</a>
</section>


<section id="linkedlist" class="doc-section">
  <h1 class="ds-heading">Linked List</h1>
  <p>The <code class="code">Linked List</code> object is exactly what a developer would expect: a head <strong>node</strong> with a single <code class="parameter">next</code> pointer to the next <strong>node</strong> or <code class="parameter">null</code>.</p>
  <h2 class="method-heading">Methods</h2>
  <code class="code">constructor(value = null)</code>
  <p class="method-p">Initialize a new <code class="parameter">Linked List</code> object. Possible parameter(s) are any valid data in <em>JavaScript</em>. May or may not be initialized with a value.</p>
{% highlight javascript %}
let NoValueLinkedList = new Plus.LinkedList(); // { head: { val: null, next: null }}
let LinkedList = new Plus.LinkedList(3);       // { head: { val: 3, next: null }}
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">Linked List</code> object has the following structure:</p>
{% highlight javascript %}
{
  head: {
    val: null,
    next: null
  },

  size: 1
}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">assignHeadValue(value = null)</code>
  <p class="method-p">Assigns the head node's value to the passed parameter. This method can be used in the case that the <code class="parameter">Linked List</code> object is initialized without a value, or when the first node's value should be changed.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);                  // { head: { val: 4, next: null }, size: 1 }
LinkedListWithData.assignHeadValue([1, 2, 3]);  // { head: { val: [1, 2, 3], next: [Object] }, size: 2 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">insert(...newData)</code>
  <p class="method-p">Inserts elements of <code class="parameter">...newData</code> as nodes to the <strong>tail</strong> of the linked list. Returns <code class="parameter">this</code> for daisy-chaining.</p>
{% highlight javascript %}
LinkedList.insert(1); // { head: { val: 2, next: { val: 1, next: null }}}
LinkedList.insert(2, 3); 
/* 
{ head: { 
      val: 2, next: { 
        val: 1, next: {
          val: 2, next: {
            val: 3, next: null
        }
      } 
    }
  },

  size: 4
}
*/
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">insertAtIndex(index, ...newData)</code>
  <p class="method-p">Inserts elements of <code class="parameter">...newData</code> as nodes at the passed <strong>index</strong> of the linked list. Does not overwrite nodes already in the linked list. Returns <code class="parameter">this</code> for daisy-chaining.</p>
{% highlight javascript %}
LinkedList = new Plus.LinkedList(4);
LinkedList.insertAtIndex(0, 2, true); // { head: val: 4, next: { val: 2, next: { val: true, next: null }}}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">removeByValue(value)</code>
  <p class="method-p">Removes the <strong>first</strong> node with given <strong>value</strong> and returns <code class="parameter">value</code>. Returns <code class="parameter">null</code> if the value is not found.</p>
{% highlight javascript %}
LinkedList.insert(2, 3, 4);
LinkedList.removeByValue(3); // 3
LinkedList.removeByValue(3); // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">removeByIndex(index)</code>
  <p class="method-p">Removes the <strong>first</strong> node with given <strong>value</strong> and returns <code class="parameter">value</code>. Returns <code class="parameter">null</code> if the index is not found, the index is not a number, or the index is less than <code class="parameter">-1</code>.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.removeByIndex(-1);   // null
LinkedList.removeByIndex('0');  // null
LinkedList.removeByIndex(0);    // 4
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getNodeAtIndex(index)</code>
  <p class="method-p">Returns the <strong>node</strong> at the given <strong>index</strong>. Returns <code class="parameter">null</code> if the index is not found.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.getNodeAtIndex(1);   // null
LinkedList.getNodeAtIndex(0);   // { val: 4, next: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getNodeIndexByValue(value)</code>
  <p class="method-p">Returns the <strong>first node</strong> and <strong>index</strong> for the given <strong>value</strong>.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.getNodeIndexByValue(1);   // null
LinkedList.getNodeIndexByValue(4);   // { node: { val: 4, next: null }, index: 0 }
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">object</code> has the following structure:</p>
{% highlight javascript %}
{ 
  node: { val: null, next: null }, // this is the returned node
  index: null                      // this is the index of that node
}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">updateValueAtIndex(index, value)</code>
  <p class="method-p">Updates the <code class="parameter">val</code> property of the <strong>node</strong> at the given <code class="parameter">index</code>. Returns <code class="parameter">this || null</code> depending on the success of the invocation.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.updateValueAtIndex(0, true);  // { head: { val: true, next: null }, size: 1 }
LinkedList.updateValueAtIndex(4, false); // null
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getMiddleNode()</code>
  <p class="method-p">Returns the <strong>node</strong> in the middle of the <code class="parameter">Linked List</code> object. Returns <code class="parameter">undefined</code> for a list with no middle.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.insert(1, 2, 3, 5);
LinkedList.getMiddleNode(); // { val: 2, next: [Object] }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">tail()</code>
  <p class="method-p">Returns the <strong>last node</strong> in the <code class="parameter">Linked List</code> object.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.tail(); // { val: 4, next: null }
LinkedList.insert(2);
LinkedList.tail(); // { val: 2, next: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">removeByTail()</code>
  <p class="method-p">Removes the <strong>last node</strong> in the <code class="parameter">Linked List</code> object. Returns <code class="parameter">value</code> from deleted node.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.removeByTail(); // 4
LinkedList.assignHeadValue(4).insert(1, 2);
LinkedList.removeByTail(); // 2
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">toArray()</code>
  <p class="method-p">Returns <code class="parameter">[]</code> comprised of the <strong>values</strong> from the nodes in the <code class="parameter">Linked List</code> object, starting from the <strong>head</strong> and ending with the <strong>tail</strong>.</p>
{% highlight javascript %}
LinkedListEmpty.toArray(); // [];
LinkedList.assignHeadValue(4);
LinkedList.toArray();      // [4];
LinkedList.insert(2, 3);   // [4, 2, 3];
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">reverse()</code>
  <p class="method-p">Returns <code class="parameter">this</code> and <strong>destructively</strong> reverses the nodes in the <code class="parameter">Linked List</code> object, starting from the <strong>head</strong> and ending with the <strong>tail</strong>.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.insert(2, 3);
LinkedList.reverse(); // { head: { val: 3, next: { val: 2, next: { val: 4, next: null }}}, size: 3 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">clear()</code>
  <p class="method-p">Returns <code class="parameter">this</code> and <strong>destructively</strong> clears the nodes in the <code class="parameter">Linked List</code> object.</p>
{% highlight javascript %}
LinkedList.clear(); // { head: { val: undefined, next: null }, size: 1 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">contains(value)</code>
  <p class="method-p">Returns <code class="parameter">true || false</code> depending on whether the passed <strong>value</strong> can be found in the <code class="parameter">Linked List</code> object.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.contains(4); // true
LinkedList.contains(1); // false
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">length()</code>
  <p class="method-p">Returns <code class="parameter">this.size</code>, which is a count of the <strong>nodes</strong> in the <code class="parameter">Linked List</code> object. This will always be an integer greater than or equal to <code class="parameter">1</code>.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.length(); // 1
LinkedList.insert(2, 3);
LinkedList.length(); // 3
LinkedList.removeByValue(2);
LinkedList.length(); // 2
LinkedList.removeByValue(1);
LinkedList.length(); // 1
LinkedList.removeByValue(3);
LinkedList.length(); // 1
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">count(value = null)</code>
  <p class="method-p">Returns <strong>count</strong> of how many nodes in the <code class="parameter">Linked List</code> object have a <code class="parameter">val</code> property with <code class="parameter">value</code>.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.count();       // null
LinkedList.count(4);      // 1
LinkedList.count(1);      // 0
let arr = [1, 2];
LinkedList.insert(arr);
LinkedList.count(arr);    // 1
LinkedList.count([1, 2]); // 0
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">countMultiple(...values)</code>
  <p class="method-p">Returns an <strong>object</strong> with properties which represent the <strong>count</strong> of that given property in the <code class="parameter">Linked List</code> object. The value must be <strong>deeply equal</strong> to the <code class="parameter">val</code> property of a given node. Only <strong>strings</strong> and <strong>numbers</strong> may be used as values. Use <code class="parameter">count(value)</code> for getting the count of specific objects.</p>
{% highlight javascript %}
LinkedList.assignHeadValue(4);
LinkedList.insert(3, 'one', 'one', 1, 'two', ['one']);
LinkedList.countMultiple(4, 3, 'one', 'two', 2, { one: 'yes' }, ['one']); 
// { 4: 1, 3: 1, 'one': 2, 'two': 1, 2: 0 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <a href="#title" class="topper">Back to Top</a>
</section>

<section id="bt" class="doc-section">
<h1 class="ds-heading">Binary Tree</h1>
  <p>The main difference between <code class="code">BinaryTree</code> and <code class="code">BST</code> objects are that the former have no data constraints. This means that <strong>any</strong> data can be inserted into the tree; however, the <code class="code">BST</code> object enforces data consistency which creates <code class="parameter">O(log2n)</code> search, insert, and removal times.</p>
  <h2 class="method-heading">Methods</h2>
  <code class="code">constructor(array = [1])</code>
  <p class="method-p">Initialize a new <code class="parameter">BinaryTree</code> object. Possible parameter value(s) are: <code class="parameter">[]</code>.</p>
  <p class="method-p">Use <code class="parameter">undefined</code> for nodes in the tree which should be <code class="parameter">null</code>.</p>
{% highlight javascript %}
let BinaryTree = new Plus.BinaryTree([2, 1, 3]);
let BinaryTree = new Plus.BinaryTree([1, 2, 3, 4, 5, 6, undefined, undefined, undefined, 8]);
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">BinaryTree</code> object has the following structure:</p>
{% highlight javascript %}

// 1

{
  root: { 
          val: 2, 
          left: { val: 1, left: null, right: null}, 
          right: { val: 3, left: null, right: null }
        } 
}

// 2
{
  root: { 
    val: 1,
      left: 
       { val: 2,
         left: { val: 4, left: [Object], right: [Object], height: 0 },
         right: { val: 5, left: [Object], right: null, height: 0 },
         height: 0 },
      right: 
       { val: 3,
         left: { val: 6, left: null, right: null, height: 0 },
         right: { val: null, left: null, right: null, height: 0 },
         height: 0 },
      height: 0 }
}

// Pay attention to the placement of null nodes.
{% endhighlight %}
  <p class="method-p"><strong>Nodes</strong> are inserted in <strong>level-order</strong>, meaning that the number of nodes possible for a given level dictates where each node is placed. The first level, the <strong>root</strong>, has one possible node, so the first element of <code class="parameter">[1, 2, 3, undefined...]</code> is converted to a node in that level. The next level has <strong>two</strong> possible nodes, so the next two values in the array are the <code class="parameter">left</code> and <code class="parameter">right</code> nodes of the <code class="parameter">root</code> node. Each level doubles in size.</p>
  <p class="method-p">Since the placement of nodes is entirely up the <code class="parameter">[]</code> passed in as the parameter, it is possible that the binary tree will have nodes attached to a node with a <code class="parameter">null</code> value. This may cause problems with searching for values in certain cases. For absolute certainty in the validity of the tree structure, use the <code class="code">BST</code> object.</p>
  <p class="separator">. . . . .</p>
  <code class="code">insert(value)</code>
  <p class="method-p">Replaces a <code class="parameter">null</code> value in either the <code class="parameter">left</code> or <code class="parameter">right</code> property with a new <strong>node</strong> with passed <code class="parameter">value</code>. Only one element may be passed at a time. <code class="parameter">left</code> is evaluated for a <code class="parameter">null</code> before <code class="parameter">right</code>.</p>
  <p>Returns <code class="parameter">this</code> for daisy chaining.</p>
{% highlight javascript %}
BinaryTree; 
/*
{ 
  root: {
    val: 2,
    left: null,
    right: null
  } 
}
*/
BinaryTree.insert(2).insert(3);
/*
{ 
  root: {
    val: 2,
    left: { val: 2, left: null, right: null },
    right: { val: 3, left: null, right: null }
  } 
}
*/
{% endhighlight %}
  <p class="method-p">The value is inserted in <strong>level-order</strong>, meaning that the first node in the level with either a <strong>null</strong> <code class="parameter">left</code> or <code class="parameter">right</code> is replaced with a new <code class="parameter">TreeNode</code> with the passed <code class="parameter">value</code>.</p>
  <p class="separator">. . . . .</p>
  <code class="code">remove(value)</code>
  <p class="method-p">Removes the first <strong>node</strong> with the passed <code class="parameter">value</code> and returns <code class="parameter">this</code> for daisy chaining. Will <strong>not</strong> return <code class="parameter">null</code> if the given <code class="parameter">value</code> cannot be found.</p>
{% highlight javascript %}
BinaryTree;
/*
{ 
  root: {
    val: 2,
    left: null,
    right: null
  } 
}
*/
BinaryTree.insert(2).insert(3).remove(3);
/*
{
  root: {
    val: 1,
    left: { val: 2, left: null, right: null }
    right: null
  }
}
*/
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getNode(value)</code>
  <p class="method-p">Returns the <strong>first</strong> node with the passed <code class="parameter">value</code>. Will return <code class="parameter">null</code> if the node cannot be found.</p>
{% highlight javascript %}
BinaryTree;
/*
{
  root: {
    val: 1,
    left: { val: 2, left: null, right: null }
    right: null
  }
}
*/
BinaryTree.getNode(2);
// { val: 2, left: null, right: null }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">findHeight(node)</code>
  <p class="method-p">Returns a <code class="parameter">number</code> representing the height of the passed <code class="parameter">node</code>. Throws an error if the passed <code class="parameter">node</code> does not have <code class="parameter">TreeNode</code> as its prototype object.</p>
{% highlight javascript %} 
let BinaryTree = new Plus.BinaryTree([10, 20, 
                                      30, undefined, 
                                      undefined, undefined, 
                                      40]);
let node = BinaryTree.getNode(30);
BinaryTree.findHeight(node); // 1
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">findMaxDepth()</code>
  <p class="method-p">Returns a <code class="parameter">number</code> representing the maximum depth of <code class="parameter">this.root</code>.</p>
{% highlight javascript %}
let arr = [1, 2, 3, 4, 5, 6, 7, 8];
let BinaryTree = new Plus.BinaryTree(arr);
BinaryTree.findMaxDepth(); // 4
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getValuesTraversal(type = 'post')</code>
  <p class="method-p">Returns an <code class="parameter">[]</code> representing the elements in a certain order traversal. The possible options are in: <code class="parameter">['post', 'pre', 'in']</code>. Will <strong>not</strong> include <code class="parameter">null</code> values in the return value.</p>
{% highlight javascript %}
let BinaryTree = new Plus.BinaryTree(1);
BinaryTree.insert(2).insert(3);
BinaryTree.getValuesTraversal();      // [2, 3, 1]
BinaryTree.getValuesTraversal('pre'); // [1, 2, 3]
BinaryTree.getValuesTraversal('in');  // [2, 1, 3]
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">manipulateTraversal(func, type = 'post')</code>
  <p class="method-p">Mutates <code class="parameter">this.root</code> with the passed function, <code class="parameter">func</code>, in whatever order designated by the passed <code class="parameter">type</code> parameter. The possible options for <code class="parameter">type</code> are: <code class="parameter">['post', 'pre', 'in']</code>. Returns <code class="parameter">this</code> which makes it daisy chainable.</p>
{% highlight javascript %}
const double = (node) => {
  return node.val = node.val * 2;
};

let BinaryTree = new Plus.BinaryTree(1);
BinaryTree.insert(2).insert(3);
BinaryTree.manipulateTraversal(double); 
BinaryTree.getValuesTraversal();       // [2, 3, 1]
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <a href="#title" class="topper">Back to Top</a>
</section>

<section id="bst" class="doc-section">
  <h1 class="ds-heading">Binary Search Tree</h1>
  <p><code class="code">BST</code> objects are self-balancing, meaning that the difference in height between the <code class="parameter">left</code> and <code class="parameter">right</code> branches of a given node cannot be less than <strong>-1</strong> or greater than <strong>1</strong>.</p>
  <p>The type of Binary Search Tree used in this class is an <strong>AVL Tree</strong>.</p>
  <p>All nodes in the tree <strong>must</strong> have unique values.</p>
  <h2 class="method-heading">Methods</h2>
  <code class="code">constructor(dataType, options)</code>
  <p class="method-p">Initialize a new <code class="parameter">BST</code> object.</p>
  <p>The <code class="parameter">dataType</code> parameter represents the single type of data that the initialized <code class="parameter">BST</code> object can store. The possible options are in the following array and correspond to the actual primitive and/or object in vanilla <em>JavaScript</em>: <code class="parameter">['number', 'string', 'date', 'object']</code>. Only pass <strong>one string</strong>, otherwise an error will be thrown.</p>
  <p>The <code class="parameter">options</code> parameter represents an optional <strong>object</strong> which may be passed into the constructor function to further customize the way data is handled in the <code class="parameter">BST</code> object. The only properties available to this object are in the following arrays: <code class="parameter">['key', 'keyType', 'compareFunction']</code> for <code class="parameter">'object'</code> typed trees, and <code class="parameter">['compareFunction']</code> for <code class="parameter">['number', 'string', 'date']</code> typed trees.</p>
{% highlight javascript %}
// For Date, String, or Number BSTs

let options = { compareFunction: exampleFunc };

// For Object

let options = { 
  key: 'bigId',
  keyType: 'number',
  compareFunction: sortByIdOrSomething 
};

{% endhighlight %}
  <p><code class="parameter">key</code> represents the property that will be on <strong>every</strong> object passed into the <code class="parameter">BST</code> object. This key is then used to sort and balance the tree as elements are inserted and removed. This must be a <strong>string</strong>.</p>
  <p><code class="parameter">keyType</code> represents the type of primitive data that will be stored in the <code class="parameter">key</code> property of each object. The available options are in the following array: <code class="parameter">['string', 'number']</code>. Incorrect values will result in thrown errors.</p>
  <p><code class="parameter">compareFunction</code> represents the function which will be used to determine if one value is less than another value. Using this, the tree will insert, remove, and rebalance itself. This can be passed with any data type, not just <code class="parameter">object</code>.</p>
  <p>The function must come in the following form:</p>
{% highlight javascript %}
// this example would work for strings

const exmapleCompareForStrings = function(a, b) {
  return a.length < b.length;  
};

// this example would work for an object with key: id

const sortById = function(a, b) { // this works for objects
  return a.id < b.id;
};

// this example would work for a number BST

const sortByDivision = function(a, b) {
  return (a / 2) < (b / 3);  
};

// Notice that the expression must be: a < b.
{% endhighlight %}
  <p class="method-p"><code class="parameter">BST</code> objects may be instantiated as shown in the following code snippet:</p>
{% highlight javascript %}
let StringBST = new Plus.BST('string');
let NumberBST = new Plus.BST('number');
let DateBST = new Plus.BST('date', { compareFunction: sortByDay });
let ObjectBST = new Plus.BST('object', {
  key: 'id',
  keyType: 'number',
  compareFunction: sortById  
});

// String and Number BSTs can also be passed compareFunction.
{% endhighlight %}
  <p class="method-p">The returned <code class="parameter">BST</code> object has the following structure:</p>
{% highlight javascript %}
{
  type: dataType,        // determines valid data
  compareFunction: func, // for all data
  key: undefined,        // for objects
  keyType: undefined,    // for objects
  duplicates: {},        // prevents duplicates
  size: 0,               // allows for constant time tree size lookup
  root: null             // this is where the tree is stored
}
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">insert(values)</code>
  <p class="method-p">Inserts node(s) with the passed <code class="parameter">value</code> property. To pass several elements at once, pass an <code class="parameter">[]</code> with the elements separated with commas.</p>
{% highlight javascript %}
let NumberBST = new Plus.BST('number');
NumberBST.insert(1); 
NumberBST.insert([2, 3]).insert(5); // can chain methods, too
/*
{
  root: {
    val: 2,
    left: { val: 1, left: null, right: null },
    right: { val: 3, left: null, right: { val: 5, left: null, right: null }}
  }
}
*/
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">remove(values)</code>
  <p class="method-p">Removes node(s) with the passed <code class="parameter">value</code> property. To pass several elements at once, pass an <code class="parameter">[]</code> with the elements separated with commas. Returns <code class="parameter">this</code>, so methods can be chained after its invocation.</p>
{% highlight javascript %}
let DateBST = new Plus.BST('date');
DateBST.insert([new Date('November 15, 2020'),
                new Date('December 25, 2020'),
                new Date('March 25, 2020'),
                new Date('July 4, 2029')]);
DateBST.remove(new Date('July 4, 2029'));
/*
{
  root: {
    val: December 25, 2020     // not real formatting
    left: November 14, 2020,   // not real formatting
    right: March 25,, 2020     // not real formatting
  }
}
*/
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">maxValue(root = this.root)</code>
  <p class="method-p">Returns the node with the greatest <code class="parameter">val</code> property.</p>
{% highlight javascript %}
let ObjectBST = new Plus.BST('object', {
  key: 'id',
  keyType: 'number',
  compareFunction: sortById  
});

ObjectBST.insert([
  { id: 1 },
  { id: 2 },
  { id: 3 }
]);

ObjectBST.maxValue(); // { id: 3 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">minValue(root = this.root)</code>
  <p class="method-p">Returns the node with the smallest <code class="parameter">val</code> property.</p>
{% highlight javascript %}
let ObjectBST = new Plus.BST('object', {
  key: 'id',
  keyType: 'number',
  compareFunction: sortById  
});

ObjectBST.insert([
  { id: 1 },
  { id: 2 },
  { id: 3 }
]);

ObjectBST.minValue(); // { id: 1 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">search(value, root = this.root)</code>
  <p class="method-p">Returns the node from <code class="parameter">this.root</code> with the passed <code class="parameter">value</code> if it exists. Returns <code class="parameter">null</code> if there are no elements which match the passed value.</p>
  <p class="method-p"><code class="parameter">Objects</code> will be matched with the <code class="parameter">toString()</code> method, so deep equality is <strong>not necessary</strong> for the <code class="parameter">search</code> method to return the correct node.</p>
{% highlight javascript %}
let ObjectBST = new Plus.BST('object', {
  key: 'id',
  keyType: 'number',
  compareFunction: sortById  
});

ObjectBST.insert([
  { id: 1 },
  { id: 2 },
  { id: 3 }
]);

ObjectBST.search({ id: 1 }); // { id: 1 }
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">length()</code>
  <p class="method-p">Returns <code class="parameter">this.size</code>, which is the number of nodes in the tree.</p>
{% highlight javascript %}
let StringBST = new Plus.BST('string');
StringBST.insert(['coal', 'mining', 'is', 'no', 'fun']);
StringBST.length(); // 5
StringBST.remove('coal').remove('mining');
StringBST.length(); // 3
StringBST.remove(['is', 'no']);
StringBST.length(); // 1
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">contains(value)</code>
  <p class="method-p">Returns <code class="parameter">true || false</code>, depending on if <code class="parameter">value</code> is a property on <code class="parameter">this.duplicates</code> with <code class="parameter">true</code> value.</p>
{% highlight javascript %}
let NumberBST = new Plus.BST('number');
NumberBST.insert([1, 2, 3]);
NumberBST.contains(4); // false
NumberBST.contains(1); // true
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">isEmpty()</code>
  <p class="method-p">Returns <code class="parameter">true || false</code>, depending on if <code class="parameter">this.root</code> is <code class="parameter">null</code>.</p>
{% highlight javascript %}
let NumberBST = new Plus.BST('number');
NumberBST.isEmpty(); // true

NumberBST.insert([1, 2, 3]);
NumberBST.isEmpty(); // false
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <code class="code">getValuesTraversal(type = 'post')</code>
  <p class="method-p">Returns an <code class="parameter">[]</code> representing the elements in a certain order traversal. The possible options are in: <code class="parameter">['post', 'pre', 'in']</code>. Will <strong>not</strong> include <code class="parameter">null</code> values in the return value.</p>
{% highlight javascript %}
let NumberBST = new Plus.BST('number');
NumberBST.insert([1, 2, 3, 4]);
NumberBST.getValuesTraversal(); // [1, 4, 3, 2]
{% endhighlight %}
  <p class="separator">. . . . .</p>
  <a href="#title" class="topper">Back to Top</a>
</section>